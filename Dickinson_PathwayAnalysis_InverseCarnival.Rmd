---
title: "Dickinson (2018) - analysis"
author: "TJ McColl"
date: "07/10/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
Here I attempt to analyze the data from Dickinson (2018) using CARNIVAL. 
The Dickinson (2018) provides data on 6 subjects at basal, 1 and 4 hours following aerobic exercise, and 1 and 4 hours following resistance exercise.

```{r, message=FALSE}
rm(list=ls()) 

## loading libraries
library(plyr)
library(dplyr)
library(readr)
library(ggplot2)
library(reshape)
library(pheatmap)
library(gridExtra)
library(grid)
library(cowplot)
library(ggrepel)
library(hexbin)
library(vsn)

setwd("/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL")
source("support_functions.R")
```

### 1: Data importing and manipulation
```{r, message=FALSE}
knitr::opts_knit$set(root.dir = '/tmp')

setwd("/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/GSE107934_RAW")

fileList = list.files(pattern = ".*.txt.gz") 

data_all = list.files(pattern = ".*.txt.gz") %>%
  lapply(read.table) %>%
  bind_cols

count_df = data_all[,c(seq(2,58,2))]
count_df

row.names(count_df) = data_all$V1...1
count_df

dataSet_names = c("basal.P1", "AT.1h.P1", "AT.4h.P1", "RT.1h.P1", "RT.4h.P1",
                  "basal.P2", "AT.1h.P2", "AT.4h.P2", "RT.1h.P2", "RT.4h.P2",
                  "basal.P3", "AT.1h.P3", "AT.4h.P3", "RT.1h.P3", "RT.4h.P3",
                  "basal.P4", "AT.1h.P4",             "RT.1h.P4", "RT.4h.P4",
                  "basal.P5", "AT.1h.P5", "AT.4h.P5", "RT.1h.P5", "RT.4h.P5",
                  "basal.P7", "AT.1h.P7", "AT.4h.P7", "RT.1h.P7", "RT.4h.P7")

names(count_df) = dataSet_names
```

```{r}
head(count_df)
```

## Pre-processing and normalization
```{r}
targets <- as.data.frame(matrix(NA,length(names(count_df)),2))

names(targets) <- c("sample","condition")

targets$sample <- names(count_df)

targets$condition <- gsub(".P[1-7]$","",targets$sample)

head(targets)
```

```{r}
count_df <- count_df[rowSums(count_df) > 0,]
count_df[count_df == 0] <- NA
```

```{R}
plots <- magicPlotMakerLight(df = log2(count_df), targets = targets)
plot(plots[[1]] + geom_hline(yintercept=0.5)) 
plot(plots[[2]]) 
```
There is a bimodal distribution based on the violin plot, usually this is because a lot of genes are expressed under the RNAseq detection threshold and will give rise to a noisy sub-distribution. Hence we want to rid of those reads and the transcripts with less than 3 log2(counts) are excluded (Usually, a cleaned-up dataframe will have roughly between 9000 and 15000 measured genes).

**check if 3 log2(counts) is appropriate (4 log2(counts) only provided ~6000 genes)
  -> adjusted to '0.5 log2(counts)' -> as seen with hline above, bimodal distribution is at ~0.5.
```{r}
count_df[log2(count_df) < 0.5 ] <- NA
count_df <- count_df[rowSums(is.na(count_df[,c(1:3)])) < 2,] 
count_df <- count_df[rowSums(is.na(count_df[,c(4:6)])) < 2,]
```

## VSN Normalization

```{r}
## now we can normalise the cleaned dataframe using vsn
fit <- vsn::vsnMatrix(as.matrix(count_df)) #train vsn parameters

## make sure the mean/sd trend is not going crazy
## red line: running median estimator of standard deviation of feature level data
## we assume that most genes are not differentially expressed, so after variance stabilization, the red line should be relatively flat.
meanSdPlot(fit)
```
The mean/sd trend is reasonably flat (i.e., red line) and there is minimal fragmenting. Good to continue

```{r}
## predict using the fit data from last step
count_df_vsn <- as.data.frame(vsn::predict(fit, as.matrix(count_df)))
```

```{r}
## whether subjects separate into distinct groups based on the continuous response - expression level
## PC1: explains most of the variability, best fit of data points
plots <- magicPlotMakerLight(df = log2(count_df_vsn), targets = targets)
plot(plots[[1]]) #violins
plot(plots[[2]]) #PCA
```
Are the conditions separated adequately by the second component? There is good separation between basal and AT_4h / RT_4h. There is some lack of separation between basal and AT_1h / RT_1h, such that there is unlikely to be much difference in gene expression (logical as gene expression likely requires a longer time frame to take full effect). 

## Identifier kung-fu (i.e., switching from Ensembl IDs to UniProt)
```{r}
gene_id_mapping_from_uniprot <- as.data.frame(
  read_delim("/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/support/gene_id_mapping_from_uniprot.tab", 
             "\t", escape_double = FALSE, trim_ws = TRUE))
gene_id_mapping_from_uniprot <- gene_id_mapping_from_uniprot[!is.na(gene_id_mapping_from_uniprot$`Gene names`),]
ensembl_to_symbol <- gsub(" .*","",gene_id_mapping_from_uniprot$`Gene names`)
names(ensembl_to_symbol) <- gene_id_mapping_from_uniprot[,1]

## remove all genes that have no gene symbol from our count dataframe
row.names(count_df_vsn) <- gsub("[.][1-7]*","",row.names(count_df_vsn))

## eliminate the gene names not mapped to ensembl_to_symbol
count_df_vsn <- count_df_vsn[row.names(count_df_vsn) %in% names(ensembl_to_symbol),]

## now let's convert ids with the pseudo dictionary
## now all gene names are replaced with those from uniprot
for(i in 1:length(count_df_vsn[,1]))
{
  row.names(count_df_vsn)[i] <- ensembl_to_symbol[row.names(count_df_vsn)[i]]
}

```

## Write count and target files for further analysis
```{r}
to_write <- count_df_vsn
to_write$gene <- row.names(to_write)
to_write <- to_write[,c(length(to_write[1,]),1:(length(to_write[1,])-1))]
write_csv(to_write, 
          file = "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/count_df_vsn.csv")
write_csv(targets, "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/support/targets.csv")
```

### 2: Differential analysis
Differential analysis of the transcriptomic data
```{r}
library(limma)
```

### Limma differential analysis
Simple differential analysis using Limma
```{r}
unique(targets$condition)
```
```{r}
#creating comparisons to test
comparisons = list("B_vs_AT.1h"=c(2,-1), "B_vs_AT.4h"=c(3,-1), "AT.1h_vs_AT.4h"=c(3,-2), 
                   "B_vs_RT.1h"=c(4,-1), "B_vs_RT.4h"=c(5,-1), "RT.1h_vs_RT.4h"=c(5,-4))  

#runLimma parameters:
#'@param measurments the normalized measurment n*m dataframe (n is number of omic features (8470-number of genes), 
#'m is number of samples (29)) where columns are ordered by conditions.
#'@param targets A n*2 dataframe, where n is the number of samples (29 in our case). First column correspond to samples, second column correspond to conditions.
#'@param comparisons a list of numeric vectors. Each vector represent which condition should be compared.
limmaRes = runLimma(measurements = count_df_vsn,
                    targets = targets,
                    comparisons = comparisons)

```
```{r}
ttop_B_vs_AT.1h <- ttopFormatter(topTable(limmaRes[[1]], coef = 1, number = length(count_df_vsn[,1]), adjust.method = "fdr"))
null_model <- pnorm(rnorm(length(ttop_B_vs_AT.1h[,1])))
plot(sort(null_model), sort(ttop_B_vs_AT.1h$P.Value) ,
     xlim = c(1,0), ylim = c(1,0),
     title("AT 1 hour versus basal")) 
abline(coef = c(0,1))
```
This plot is used to see the deviance from the diagonal line. Deviance above the diagonal indicates an increase in expression (smaller p-values vs a random sample), deviance below the diagonal indicates a lower level of expression (larger p-value vs a random sample)

As suspected, there is a lack of expression between basal and AT.1hr

```{r}
#Basal versus AT 4 hour
ttop_B_vs_AT.4h <- ttopFormatter(topTable(limmaRes[[1]], coef = 2, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_B_vs_AT.4h[,1])))
plot(sort(null_model), sort(ttop_B_vs_AT.4h$P.Value), 
     xlim = c(1,0), ylim = c(1,0), 
     title("AT 4 hour versus basal"))
abline(coef = c(0,1))
```
As suspected, there is an increase in expression between basal and AT.4hr (deviance above diagonal)

```{r}
#AT 1 hour versus AT 4 hour
ttop_AT.1h_vs_AT.4h <- ttopFormatter(topTable(limmaRes[[1]], coef = 3, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_B_vs_AT.4h[,1])))
plot(sort(null_model), sort(ttop_B_vs_AT.4h$P.Value), 
     xlim = c(1,0), ylim = c(1,0),
     title("AT 4 hour versus AT 1 hour"))
abline(coef = c(0,1))
```
```{r}
#Basal versus RT 1 hour
ttop_B_vs_RT.1h <- ttopFormatter(topTable(limmaRes[[1]], coef = 4, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_B_vs_RT.1h[,1])))
plot(sort(null_model), sort(ttop_B_vs_RT.1h$P.Value), 
     xlim = c(1,0), ylim = c(1,0),
     title("RT 1 hour versus basal")) 
abline(coef = c(0,1))
```
Low level of expression

```{r}
#Basal versus RT 4 hour
ttop_B_vs_RT.4h <- ttopFormatter(topTable(limmaRes[[1]], coef = 5, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_B_vs_RT.4h[,1])))
plot(sort(null_model), sort(ttop_B_vs_RT.4h$P.Value), 
     xlim = c(1,0), ylim = c(1,0),
     title("RT 4 hour versus basal"))
abline(coef = c(0,1))
```
Quite high level of expression

```{r}
#RT 1 hour versus RT 4 hour
ttop_RT.1h_vs_RT.4h <- ttopFormatter(topTable(limmaRes[[1]], coef = 6, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_RT.1h_vs_RT.4h[,1])))
plot(sort(null_model), sort(ttop_RT.1h_vs_RT.4h$P.Value),
     xlim = c(1,0), ylim = c(1,0),
     title("RT 4 hour versus RT 1 hour")) 
abline(coef = c(0,1))
```

##Write the differential analysis output
```{r}
write_csv(ttop_B_vs_AT.1h, 
          file = "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/ttop_B_vs_AT.1h.csv") #no diff
write_csv(ttop_B_vs_AT.4h, 
          file = "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/ttop_B_vs_AT.4h.csv")
write_csv(ttop_AT.1h_vs_AT.4h, 
          file = "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/ttop_AT.1h_vs_AT.4h.csv")
write_csv(ttop_B_vs_RT.1h, 
          file = "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/ttop_B_vs_RT.1h.csv") #no diff
write_csv(ttop_B_vs_RT.4h, 
          file = "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/ttop_B_vs_RT.4h.csv") #high
write_csv(ttop_RT.1h_vs_RT.4h, 
          file = "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/ttop_RT.1h_vs_RT.4h.csv")
```

### 3: Pathway activity (PROGENy)
Here I estimate the pathway activity from the Dickinson transcriptomic data using PROGENy

```{r}
#loading additional libraries
library(progeny)
library(dorothea)
library(tibble)
library(tidyr)
```

```{r}
Normalised_counts = count_df_vsn
Experimental_design = targets
```

Adjusting the format of the input files to make it suitable for running PROGENy

```{r}
Normalised_counts_matrix <- Normalised_counts %>% 
    dplyr::mutate_if(~ any(is.na(.x)),~ if_else(is.na(.x),0,.x)) %>% 
    # tibble::column_to_rownames(var = "gene") %>% 
    as.matrix()

#Comparison of each condition
ttop_B.vs.AT.1h_matrix <- ttop_B_vs_AT.1h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_B_vs_AT.4h_matrix <- ttop_B_vs_AT.4h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_AT.1h_vs_AT.4h_matrix <- ttop_AT.1h_vs_AT.4h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_B_vs_RT.1h_matrix <- ttop_B_vs_RT.1h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_B_vs_RT.4h_matrix <- ttop_B_vs_RT.4h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_RT.1h_vs_RT.4h_matrix <- ttop_RT.1h_vs_RT.4h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

```

## Pathway activity with Progeny (pathway activity estimator)
PROGENy estimates the activity of signaling pathways by combining corresponding gene sets with a linear model.
Other bulk tools: classic GO analysis combining GO gene sets with GSEA.
DoRothEA is a collection of resources of TF’s targets (regulons) that can serve as gene sets for TF activity inference.

First compute Progeny scores for every sample (with the replicates) using the normalised counts. It is worth noting that we are going to use the 200 most responsive genes per pathway (suggest 200-500)
-> changed to top 100 as per Aurelien

```{r}
PathwayActivity_counts <- progeny(Normalised_counts_matrix, scale=TRUE, organism="Human", top = 100)
Activity_counts <- as.vector(PathwayActivity_counts)
```

results in a heatmap
```{r}
paletteLength <- 100
myColor <- colorRampPalette(c("darkblue", "whitesmoke","indianred"))(paletteLength)

progenyBreaks <- c(seq(min(Activity_counts), 0, 
    length.out=ceiling(paletteLength/2) + 1),
    seq(max(Activity_counts)/paletteLength, 
    max(Activity_counts), 
    length.out=floor(paletteLength/2)))

progeny_hmap <- pheatmap(t(PathwayActivity_counts),fontsize=14, 
    fontsize_row = 10, fontsize_col = 10, 
    color=myColor, breaks = progenyBreaks, 
    main = "PROGENy (100)", angle_col = 45,
    treeheight_col = 0,  border_color = NA)

#Pathways:
#NFkB Pathway: Moderate exercise training decreases NF-kB activation and represses inflammatory gene expression, most active in basal or AT/RT.1h conditions.
#TNF-a Pathway: Regulates inflammation and tissue injury. TNF-α was elevated immediately following acute heavy resistance exercise, and decreased at 24 h and 48 h into recovery in those receiving no treatments. 
#PI3K-Akt Pathway is an intracellular signal transduction pathway that promotes metabolism, proliferation, cell survival, growth and angiogenesis in response to extracellular signals.

```
## AT 1 hour vs basal
## To do: AT 4 hour vs basal
```{r}
PathwayActivity_zscore <- progeny(ttop_B.vs.AT.1h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>% #add column name to all rows
    dplyr::arrange(NES) %>% #sort pathway by ascending NES
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("AT 1 hour versus basal") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```
The MAPK pathway is the most active pathway at the 1 hour mark following AT. We can therefore visualize the MAPK most responsive genes (progeny weights) along with their t_values to interpret the results. In the scatterplot, we can see the genes that are contributing the most to the pathway enrichment. 

```{r ProgenyScatter_1_AT1.vs.B, message=FALSE, warning=FALSE}
prog_matrix <- getModel("Human", top=100) %>% 
    as.data.frame()  %>%
    tibble::rownames_to_column("GeneID")

ttop_B_vs_AT.1h_df <- ttop_B.vs.AT.1h_matrix %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column("GeneID")

scat_plots <- progeny::progenyScatter(df = ttop_B_vs_AT.1h_df, #y, gene level stat t values
    weight_matrix = prog_matrix, #x
    statName = "t_values", verbose = FALSE)
```

```{r ProgenySccater_2_AT1.vs.B, dpi=300}
plot(scat_plots[[1]]$`MAPK`) # red/blue = positive/negative contributions of genes to the progeny pathway score

```
Progeny results as an optional input for **CARNIVAL**. I therefore run **PROGENy** again with slightly different parameters, setting `z_scores = FALSE` so that **PROGENy** returns pathway activity values (normalized z score) between 1 and -1, rather than converting to Z-Scores.

```{r ProgenyCARNIVAL_AT1.vs.B}
PathwayActivity_CARNIVALinput_B_vs_AT.1h <- progeny(ttop_B.vs.AT.1h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = FALSE) %>%
    t () %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "Pathway") 
colnames(PathwayActivity_CARNIVALinput_B_vs_AT.1h)[2] <- "score"
write_csv(PathwayActivity_CARNIVALinput_B_vs_AT.1h, 
    "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/Results/PathwayActivity_CARNIVALinput_B_vs_AT.1h.csv")
```

## AT 4 hour vs basal
```{r}
PathwayActivity_zscore <- progeny(ttop_B_vs_AT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("AT 4 hour versus basal") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```
```{r ProgenyScatter_1_AT4.vs.B, message=FALSE, warning=FALSE}
prog_matrix <- getModel("Human", top=100) %>% 
    as.data.frame()  %>%
    tibble::rownames_to_column("GeneID")

ttop_B_vs_AT.4h_df <- ttop_B_vs_AT.4h_matrix %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column("GeneID")

scat_plots <- progeny::progenyScatter(df = ttop_B_vs_AT.4h_df, 
    weight_matrix = prog_matrix, 
    statName = "t_values", verbose = FALSE)
```

```{r ProgenyScatter_2_AT4.vs.B, dpi=300}
plot(scat_plots[[1]]$`NFkB`) 
```
```{r ProgenyCARNIVAL_AT4.vs.B}
PathwayActivity_CARNIVALinput_B_vs_AT.4h <- progeny(ttop_B_vs_AT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = FALSE) %>%
    t () %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "Pathway") 
colnames(PathwayActivity_CARNIVALinput_B_vs_AT.4h)[2] <- "score"
write_csv(PathwayActivity_CARNIVALinput_B_vs_AT.4h, 
    "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/Results/PathwayActivity_CARNIVALinput_B_vs_AT.4h.csv")
```

## AT 1 hour versus AT 4 hour
```{r}
PathwayActivity_zscore <- progeny(ttop_AT.1h_vs_AT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("AT 1 hour versus AT 4 hour") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```

## RT 1 hour versus basal
```{r}
PathwayActivity_zscore <- progeny(ttop_B_vs_RT.1h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("Basal versus RT 1 hour") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```


## RT 4 hour versus basal
```{r}
PathwayActivity_zscore <- progeny(ttop_B_vs_RT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("RT 4 hour versus basal") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```
```{r ProgenyScatter_1_RT4.vs.B, message=FALSE, warning=FALSE}
prog_matrix <- getModel("Human", top=100) %>% 
    as.data.frame()  %>%
    tibble::rownames_to_column("GeneID")

ttop_B_vs_RT.4h_df <- ttop_B_vs_RT.4h_matrix %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column("GeneID")

scat_plots <- progeny::progenyScatter(df = ttop_B_vs_RT.4h_df, 
    weight_matrix = prog_matrix, 
    statName = "t_values", verbose = FALSE)
```

```{r ProgenyScatter_2_RT4.vs.B, dpi=300}
plot(scat_plots[[1]]$`NFkB`) 
plot(scat_plots[[1]]$`TNFa`)
plot(scat_plots[[1]]$`MAPK`) 
plot(scat_plots[[1]]$`EGFR`) 
plot(scat_plots[[1]]$`JAK-STAT`) 


```

```{r ProgenyCARNIVAL_RT4.vs.B}
PathwayActivity_CARNIVALinput_B_vs_RT.4h <- progeny(ttop_B_vs_RT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = FALSE) %>%
    t () %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "Pathway") 
colnames(PathwayActivity_CARNIVALinput_B_vs_RT.4h)[2] <- "score"
write_csv(PathwayActivity_CARNIVALinput_B_vs_RT.4h, 
    "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/Results/PathwayActivity_CARNIVALinput_B_vs_RT.4h.csv")
```

## RT 1 hour versus RT 4 hour
```{r}
PathwayActivity_zscore <- progeny(ttop_RT.1h_vs_RT.4h_matrix, 
    scale=TRUE, organism="Human", top = 200, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("RT 1 hour versus RT 4 hour") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```

### 4: Transcription Factor activity (DoRothEA)
Here I estimate transcription factor activity from transcriptomics data using **DoRothEA**.
DoRothEA is a comprehensive resource containing a curated collection of TFs and their transcriptional targets. 
The set of genes regulated by a specific TF is known as regulon. 
Each TF-target interaction is defined by a confidence level based on the volume of supporting evidence. 
The confidence levels range from A (highest confidence) to E (lowest confidence)
```{r}
library(ggrepel)
```

Dorothea input files
```{r Dorothea inputs}
# Normalised_counts_dorothea = count_df_vsn
# Experimental_design_dorothea = targets
Normalised_counts_dorothea <- read_csv("/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/count_df_vsn.csv")
Experimental_design_dorothea <- read_csv("/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/support/targets.csv")
ttop_B_vs_AT.4h_dorothea <- read_csv("/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/ttop_B_vs_AT.4h.csv")
ttop_B_vs_RT.4h_dorothea <- read_csv("/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/data/ttop_B_vs_RT.4h.csv")
```

Modify file formats
```{r Dorothea file modification, message=FALSE}
#replace NA entries with 0
Normalised_counts_matrix_dorothea <- Normalised_counts_dorothea %>% 
    dplyr::mutate_if(~ any(is.na(.x)),~ if_else(is.na(.x),0,.x)) %>% 
    tibble::column_to_rownames(var = "gene") %>% 
    as.matrix()

ttop_B_vs_AT.4h_dorothea_matrix <- ttop_B_vs_AT.4h_dorothea %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    column_to_rownames(var = "ID") %>%
    as.matrix()

ttop_B_vs_RT.4h_dorothea_matrix <- ttop_B_vs_RT.4h_dorothea %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    column_to_rownames(var = "ID") %>%
    as.matrix()
```

## Transcription Factor activity with DoRothEA

We estimate the transcription factor (TF) activity using the **DoRothEA** R package. 
We select interactions with confidence level A, B and C. 

```{r loadDorothea, message=FALSE}
## We load Dorothea Regulons
data(dorothea_hs, package = "dorothea")
regulons <- dorothea_hs %>%
  dplyr::filter(confidence %in% c("A", "B","C"))
```

Note that for **DoRothEA**, we proceed the other way around than for **PROGENy**. 
In **PROGENy**, we calculate the pathway_activity_counts directly which is feed into pheatmap().
We have many TFs, so we cannot clearly visualize all of them in the same heatmap. 
That is why we first compute a TF activity enrichment analysis using the statistics 
from the differential expression analysis. 
This will allow us to select the TFs whose activity varies with the conditions under study. 

**DoRothEA** is usually used together with VIPER where TF activities are computed based on the mRNA 
expression levels of its targets. 
We therefore can consider TF activity as a proxy of a given transcriptional state.

@param eset ExpressionSet object or Numeric matrix containing the expression data or gene expression signatures, with samples in columns and genes in rows. Used by Protein-activity by Enriched Regulon analysis(?)
@param minsize Integer indicating the minimum number of targets allowed per regulon
@param nes Logical, whether the enrichment score reported should be normalized
Function is a wrapper for viper class using DoRothEA regulons.

--How to determine *minsize*? Viper documentation does not include a description

```{r ViperStat, message=FALSE}
tf_activities_stat_B_vs_AT.4h <- dorothea::run_viper(ttop_B_vs_AT.4h_dorothea_matrix, regulons,
    options =  list(minsize = 5, eset.filter = FALSE, 
    cores = 1, verbose = FALSE, nes = TRUE))

tf_activities_stat_B_vs_RT.4h <- dorothea::run_viper(ttop_B_vs_RT.4h_dorothea_matrix, regulons,
    options =  list(minsize = 5, eset.filter = FALSE, 
    cores = 1, verbose = FALSE, nes = TRUE))
```

## AT 4 hour versus basal
We now display the top 25 normalized enrichment scores (NES) for the TFs in a 
bar plot.

```{r ViperBarplot AT 4h vs basal, message=FALSE, dpi=300}
tf_activities_stat_top25_B_vs_AT.4h <- tf_activities_stat_B_vs_AT.4h %>%
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::rename(NES = "t") %>%
    dplyr::top_n(25, wt = abs(NES)) %>% #top 25, ordered by absolute values of NES, select both - && +ve
    dplyr::arrange(NES) %>% 
    dplyr::mutate(GeneID = factor(GeneID))

ggplot(tf_activities_stat_top25_B_vs_AT.4h, aes(x = reorder(GeneID, NES), y = NES)) + 
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Transcription Factors")
```

To interpret the results, we can use a volcano plot to look at the expression of targets of one of the 
most de(/up)regulated TFs, such as TCF4 

*Volcano plot*: blue = down regulated genes, red = upregulated genes, logFC = log(fold change). Within the volcano plot, the most up/down regulated genes are towards the right/left, respectively. And the most statistically significant genes are towards the top

```{r Volcano RT 4h vs basal, warning=FALSE, dpi=300}
targets_NFKB1 <- regulons$target[regulons$tf == "NFKB1"] #targets of "TCF4"

#'@param FCIndex the column number corresponding to the foldchanges
#'@param pValIndex the column number corresponding to the p-values
#'@param IDIndex the column number corresponding to the identifiers
#'@param straight a boolean argument to indicate if the plot should feature bi-symptotic curves 
#'or straight lines to visualise the thresholds. In this case, we use bi-symptotic curves. 
#'@param nlabels number of labels to display

volcano_nice(as.data.frame(ttop_B_vs_AT.4h_dorothea[ttop_B_vs_AT.4h_dorothea$ID %in% targets_NFKB1,]), 
    FCIndex = 2, pValIndex = 5, IDIndex = 1,nlabels = 20, label = TRUE, 
    straight = FALSE) 
```
The TF activity enrichment results provided by **Viper** are used as an input in the **CARNIVAL** method. 
**CARNIVAL** tries to infer the most likely upstream signaling events leading to the current TF activity results. 

```{r WriteCsv AT 4h vs basal}
tf_activities_CARNIVALinput_AT.4h_vs_b<- tf_activities_stat_B_vs_AT.4h %>%
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "TF") 
write_csv(tf_activities_CARNIVALinput_AT.4h_vs_b, "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/Results/TFActivity_CARNIVALinput_AT4h_vs_B.csv")
```

## RT 4 hour versus basal
```{r ViperBarplot RT 4h vs basal, message=FALSE, dpi=300}
tf_activities_stat_top25_B_vs_RT.4h <- tf_activities_stat_B_vs_RT.4h %>%
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::rename(NES = "t") %>%
    dplyr::top_n(25, wt = abs(NES)) %>%
    dplyr::arrange(NES) %>% 
    dplyr::mutate(GeneID = factor(GeneID))

ggplot(tf_activities_stat_top25_B_vs_RT.4h, aes(x = reorder(GeneID, NES), y = NES)) + 
    ggtitle("RT 4 hour versus basal: TF activity") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Transcription Factors")
```
To interpret the results, we can look at the expression of targets of one of the 
most deregulated TFs, such as ARNTL 

```{r Volcano RT 4h vs basal, warning=FALSE, dpi=300}
targets_STAT3 <- regulons$target[regulons$tf == "STAT3"]
volcano_nice(as.data.frame(ttop_B_vs_RT.4h_dorothea[ttop_B_vs_RT.4h_dorothea$ID %in% targets_STAT3,]), 
    FCIndex = 2, pValIndex = 5, IDIndex = 1,nlabels = 20, label = TRUE, 
    straight = FALSE) 

```
The TF activity enrichment results provided by **Viper** are used as an input
in the **CARNIVAL** method. **CARNIVAL** tries to infer the most likely 
upstream signaling events leading to the current TF activity results. 

```{r WriteCsv RT 4h vs basal}
tf_activities_CARNIVALinput_RT.4h_vs_b<- tf_activities_stat_B_vs_RT.4h %>%
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "TF") 
write_csv(tf_activities_CARNIVALinput_RT.4h_vs_b, "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/Results/TFActivity_CARNIVALinput_RT4h_vs_B.csv")
```

We now compute TF activities per sample (with the replicates) using the 
normalised counts. We display the results of the previous 25 TFs in a Heatmap.

```{r ViperCounts AT 4h vs basal, message=FALSE}
#The normalizing of a dataset using the mean value and standard deviation is known as scaling.
#Used mainly for data not measured in the same way.
tf_activities_counts <- 
    dorothea::run_viper(Normalised_counts_matrix_dorothea, regulons,
    options =  list(minsize = 5, eset.filter = FALSE, 
    cores = 1, verbose = FALSE, method = c("scale")))

#filter based on top 25 deregulated TFs from last step
tf_activities_counts_filter <- tf_activities_counts %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::filter(GeneID %in% tf_activities_stat_top25_B_vs_AT.4h$GeneID) %>%
    column_to_rownames(var = "GeneID") %>%
    as.matrix()

tf_activities_vector <- as.vector(tf_activities_counts_filter)
```

```{r ViperHeatMap AT 4h vs basal}
paletteLength <- 100
myColor <- 
    colorRampPalette(c("darkblue", "whitesmoke","indianred"))(paletteLength)

dorotheaBreaks <- c(seq(min(tf_activities_vector), 0, 
    length.out=ceiling(paletteLength/2) + 1),
    seq(max(tf_activities_vector)/paletteLength, 
    max(tf_activities_vector), 
    length.out=floor(paletteLength/2)))

dorothea_hmap <- pheatmap(tf_activities_counts_filter,
    fontsize=14, fontsize_row = 8, fontsize_col = 8, 
    color=myColor, breaks = dorotheaBreaks,
    main = "Dorothea ABC: AT 4h vs basal", angle_col = 45,
    border_color = NA)

```

```{r ViperCounts RT 4h vs basal, message=FALSE}
tf_activities_counts_filter <- tf_activities_counts %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::filter(GeneID %in% tf_activities_stat_top25_B_vs_RT.4h$GeneID) %>%
    column_to_rownames(var = "GeneID") %>%
    as.matrix()

tf_activities_vector <- as.vector(tf_activities_counts_filter)
```

```{r ViperHeatMap RT 4h vs basal}
paletteLength <- 100
myColor <- 
    colorRampPalette(c("darkblue", "whitesmoke","indianred"))(paletteLength)

dorotheaBreaks <- c(seq(min(tf_activities_vector), 0, 
    length.out=ceiling(paletteLength/2) + 1),
    seq(max(tf_activities_vector)/paletteLength, 
    max(tf_activities_vector), 
    length.out=floor(paletteLength/2)))
dorothea_hmap <- pheatmap(tf_activities_counts_filter,
    fontsize=14, fontsize_row = 8, fontsize_col = 8, 
    color=myColor, breaks = dorotheaBreaks,
    main = "Dorothea ABC: RT 4h vs basal", angle_col = 45,
    treeheight_col = 0,  border_color = NA)

```


## ----

### 5: Network reconstrcution with CARNIVAL
AT 4h versus B: To do
RT 4h vs B: 

```{r, message=FALSE}
library(OmnipathR)
library(visNetwork)

## We also load the support functions
source("/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/assignPROGENyScores.r")
source("/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/generateTFList.r")
```

Inputting files for carnival: AT.4h vs basal
```{r loadInput, message=FALSE}
## We read the normalised counts and the experimental design 
# tf_activities <- tf_activities_CARNIVALinput_RT.4h_vs_b
# PathwayActivity <- PathwayActivity_CARNIVALinput_B_vs_RT.4h
tf_activities <- tf_activities_CARNIVALinput_RT.4h_vs_b
PathwayActivity <- PathwayActivity_CARNIVALinput_B_vs_RT.4h

```


## Getting the scaffold network from Omnipath
Before running **CARNIVAL**, we need to create or upload a scaffold network.
This will be _"the map"_ that the ILP algorithm will follow to find the causal network.
We use **Omnipath** to obtain the signed and directed interactions from all the available resources.
CARNIVAL requires this information in a _sif_ table (node1, interaction, node2) format,
therefore we use the _consensus_ columns of direction (consensus_direction) and
sign (consensus_stimulation and consensus_inhibition) to extract it.

The query returns 0/1 as logic status of being a stimulation or an inhibition reaction. 
Thus, this output is reformulated as 1/-1 to indicate stimulation or inhibition, respectively.
We can keep either the interactions that are consistent, or both alternatives (e.g. A 1 B; A -1 B).
In this example, we keep the consistent ones.

```{r omnipathSIF, message=FALSE}

omniR <- import_omnipath_interactions()
  
# signed and directed
omnipath_sd <- omniR %>% dplyr::filter(consensus_direction == 1 & #directed with either inhibition or stimulation
                                (consensus_stimulation == 1 | 
                                 consensus_inhibition == 1
                                 ))
  
# changing 0/1 criteria in consensus_stimulation/inhibition to -1/1 (converting *both* columns to 1 or -1 - either column indicated stimulation or inhibition)
omnipath_sd$consensus_stimulation[which(omnipath_sd$consensus_stimulation == 0)] = -1
omnipath_sd$consensus_inhibition[which(omnipath_sd$consensus_inhibition == 1)] = -1
omnipath_sd$consensus_inhibition[which(omnipath_sd$consensus_inhibition == 0)] = 1

# check consistency on consensus sign and select only those in a SIF format
sif <- omnipath_sd[,c('source_genesymbol', 'consensus_stimulation', 'consensus_inhibition', 'target_genesymbol')] %>%
      dplyr::filter(consensus_stimulation==consensus_inhibition) %>%
      unique.data.frame()

sif$consensus_stimulation <- NULL
colnames(sif) <- c('source', 'interaction', 'target')
# remove complexes
sif$source <- gsub(":", "_", sif$source)
sif$target <- gsub(":", "_", sif$target)

# save SIF
write_tsv(sif, "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/Results/omnipath_carnival.tsv")

```

## Transcription Factor and pathway activities for CARNIVAL

We use the supplementary functions _generateTFList.r_ and _assignPROGENyScores.r_
to shift the formats of tf_activities and PathwayActivity to the one required by CARNIVAL.

For AT.4h vs basal:
```{r shiftFormats, message=FALSE}

# dorothea for CARNIVAL
tf_activities_carnival <- data.frame(tf_activities, stringsAsFactors = F)
rownames(tf_activities_carnival) <- tf_activities$TF
tf_activities_carnival$TF <- NULL

# generate a list with each TF and its corresponding t value
tfList = generateTFList(tf_activities_carnival, top=100, access_idx = 1)

# progeny for CARNIVAL
load(file = system.file("progenyMembers.RData",package="CARNIVAL"))

PathwayActivity_carnival <- data.frame(PathwayActivity, stringsAsFactors = F)
rownames(PathwayActivity_carnival) <- PathwayActivity_carnival$Pathway
PathwayActivity_carnival$Pathway <- NULL
progenylist = assignPROGENyScores(progeny = t(PathwayActivity_carnival), 
                                            progenyMembers = progenyMembers, 
                                            id = "gene", 
                                            access_idx = 1)
saveRDS(progenylist, "/Users/Administrator/OneDrive - Simon Fraser University (1sfu)/BPK Work Study/CARNIVAL/Results/myProgenyList.rds")
```

## Running CARNIVAL

CARNIVAL has been developed to find the causal link between the activities of the transcription factors (TFs) and the 'perturbed' nodes.
In current version, v1.0.0, we have 3 main inputs that we have to provide:

+ _measObj_: The TFs' activities (like the ones we have obtained from DoRothEA)
+ _inputObj_: The 'perturbed' nodes we want that CARNIVAL connects with the activity of TFs. 
There are 3 ways of using it:
(1) Give the name and sign of the selected nodes; 
(2) Give the name only, so the algorithm will select the sign that best fit the models,
(3) Give _NULL_ as value will create a "Perturbation" node that will try both signs for all 'initial' nodes of the given network ( _netObj_ ).
+ _netObj_: The network that will serve as map to connect the TFs' activities ( _measObj_ ) and the perturbed nodes ( _inputObj_ )

Although it is not required, a fourth object called _weightObj_ can be also given. 
This object gives values ranged from -1 to 1 for a set of nodes of the network.f
The aim of _weightObj_ is helping the solver to find optimal solutions faster.

In the present example, we use assign as perturbation nodes all the "initial" nodes (option 2),
and as _weightObj_ the PROGENy scores assigned to the most representative genes of the calculated pathways,

Please, check the [CARNIVAL](https://saezlab.github.io/CARNIVAL/) page to get some more insight.
For more specific technical details, as how to install different ILP solvers that CARNIVAL supports,
please check [CARNIVAL vignette](https://bioconductor.org/packages/release/bioc/vignettes/CARNIVAL/inst/doc/CARNIVAL.html).
C:/Program Files/IBM/ILOG/CPLEX_Studio2211/cplex/bin/x64win64/cplex.exe
```{r}
####################################################################### Standard CARNIVAL ########################################################################
# targets = c('PTK2', 'SRC', 'SHC1')
# iniciators_std = base::data.frame(base::matrix(data = c(1,1,1), nrow = 1, ncol=length(targets)), stringsAsFactors = F)
# colnames(iniciators_std) = targets
# targets = c('RPS6KB1')
# iniciators_std = base::data.frame(base::matrix(data = c(1), nrow = 1, ncol=length(targets)), stringsAsFactors = F)
# colnames(iniciators_std) = targets

# targets = c('RPS6KB1', 'EIF4EBP1', 'EIF4E') 
# iniciators_std = base::data.frame(base::matrix(data = c(1,1,1), nrow = 1, ncol=length(targets)), stringsAsFactors = F)
# colnames(iniciators_std) = targets


# targets = c('PTK2', 'SRC', 'SHC1', 'RPS6KB1', 'EIF4EBP1', 'EIF4E') #combo
# iniciators_std = base::data.frame(base::matrix(data = c(1,1,1,1,-1,-1), nrow = 1, ncol=length(targets)), stringsAsFactors = F)
# colnames(iniciators_std) = targets

# targets = c('PRKAA1','PRKAA2', 'PRKAB1','PRKAB2', 'PRKAG1', 'PRKAG2', 'PRKAG3', 'PPRC1', 'HIF1A', 'VEGFA')
# targets = c('PPRC1', 'HIF1A', 'VEGFA')
# iniciators_std = base::data.frame(base::matrix(data = c(1,1,1), nrow = 1, ncol=length(targets)), stringsAsFactors = F)
# colnames(iniciators_std) = targets

# saveRDS(iniciators_std, "/Users/luna/Desktop/BPK Work Study/CARNIVAL/Results/iniciators_std.rds")

#################################################### Inverse CARNIVAL ###########################################################################################
# iniMTX = base::setdiff(sif$source, sif$target)
# iniciators = base::data.frame(base::matrix(data = NaN, nrow = 1, ncol = length(iniMTX)), stringsAsFactors = F)
# colnames(iniciators) = iniMTX


################################################### COSMOSR to prefilter large prior knowledge network ##########################################################

# uncomment if running regular carnival
# upstream_inputs <- iniciators_std
# downstream_inputs <- data.frame(tfList$t)
# meta_network <- sif
# expressed_genes <- rownames(ttop_B_vs_RT.4h_matrix) #ttop_RT.1h_vs_RT.4h$ID
#         
# meta_network_filtered <- cosmosR:::filter_pkn_expressed_genes(expressed_genes, meta_pkn = meta_network)
# 
# #filter the inputs that are not in PKN
# upstream_inputs_filtered <- cosmosR:::filter_input_nodes_not_in_pkn(upstream_inputs, meta_network_filtered)
# downstream_inputs_filtered <- cosmosR:::filter_input_nodes_not_in_pkn(downstream_inputs, meta_network_filtered)
# 
# #Filter inputs and prune the meta_network to only keep nodes that can be found downstream of the inputs
# #The number of step is quite flexible, 7 steps already covers most of the network
# 
# n_steps <- 7
# 
# # in this step we prune the network to keep only the relevant part between upstream and downstream nodes
# meta_network_filtered <- cosmosR:::keep_controllable_neighbours(meta_network_filtered
#                                                        , n_steps,
#                                                        names(upstream_inputs_filtered))
# downstream_inputs_filtered <- cosmosR:::filter_input_nodes_not_in_pkn(downstream_inputs_filtered, meta_network_filtered)
# meta_network_filtered <- cosmosR:::keep_observable_neighbours(meta_network_filtered
#                                                               , n_steps, 
#                                                               names(downstream_inputs_filtered))
# upstream_inputs_filtered <- cosmosR:::filter_input_nodes_not_in_pkn(upstream_inputs_filtered, meta_network_filtered)
```

```{r carnival, message=FALSE}
library(CARNIVAL)
carnival_result = runCARNIVAL( measObj = data.frame(tfList$t),
                               netObj =  sif, 
                               weightObj = progenylist$score, 
                               solverPath = "/Users/Administrator/Desktop/cplex/bin/x64_win64/cplex.exe",
                               solver = "cplex",
                               timelimit=70000,
                               betaWeight = 0)

```

```{r}
print(carnival_result)
```


```{r}
getwd()
timeStamp = Sys.time()
filename = paste0(format(timeStamp, "%Y%m%d_%H%M%S_"), "carnival.rds")
carnival_result$weightedSIF <- data.frame(carnival_result$weightedSIF, stringsAsFactors = F)
carnival_result$weightedSIF$Sign <- as.numeric(carnival_result$weightedSIF$Sign)
carnival_result$weightedSIF$Weight <- as.numeric(carnival_result$weightedSIF$Weight)
carnival_result$weightedSIF = carnival_result$weightedSIF[carnival_result$weightedSIF$Weight !=0,]

carnival_result$nodesAttributes <- data.frame(carnival_result$nodesAttributes, stringsAsFactors = F)
carnival_result$nodesAttributes$ZeroAct <- as.numeric(carnival_result$nodesAttributes$ZeroAct)
carnival_result$nodesAttributes$UpAct <- as.numeric(carnival_result$nodesAttributes$UpAct)
carnival_result$nodesAttributes$DownAct <- as.numeric(carnival_result$nodesAttributes$DownAct)
carnival_result$nodesAttributes$AvgAct <- as.numeric(carnival_result$nodesAttributes$AvgAct)

saveRDS(carnival_result, file = filename)

filename_weightedSIF = paste0(format(timeStamp, "%Y%m%d_%H%M%S_"), "carnival_weightedSIF.csv")
filename_nodesAttributes = paste0(format(timeStamp, "%Y%m%d_%H%M%S_"), "carnival_nodeAttributes.csv")

write.csv(carnival_result$weightedSIF, filename_weightedSIF)
write.csv(carnival_result$nodesAttributes, filename_nodesAttributes)
```

## Session Info Details

```{r sessionInfo, echo=FALSE, eval=TRUE}
sessionInfo()
```
