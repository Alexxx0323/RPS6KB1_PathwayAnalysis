---
title: "Dickinson (2018) - analysis"
author: "TJ McColl"
date: "07/10/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
Here I attempt to analyze the data from Dickinson (2018) using CARNIVAL. The Dickinson (2018) provides data on 6 subjects at basal, 1 and 4 hours following aerobic exercise, and 1 and 4 hours following resistance exercise.

```{r, message=FALSE}
rm(list=ls()) 

## loading libraries
library(plyr)
library(dplyr)
library(readr)
library(ggplot2)
library(reshape)
library(pheatmap)
library(gridExtra)
library(grid)
library(cowplot)
library(ggrepel)
library(hexbin)
library(vsn)
setwd("/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL")
source("support/support_functions.R")
```

### 1: Data importing and manipulation

Data is imported and combined in a single data frame. Each data set is added as a separate column
```{r, message=FALSE}
knitr::opts_knit$set(root.dir = '/tmp')

## set working directory
setwd("/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/GSE107934_RAW")

## list all files endingin in 'txt.gz' using regex
fileList = list.files(pattern = ".*.txt.gz") 

data_all = list.files(pattern = ".*.txt.gz") %>%
  lapply(read.table) %>%
  bind_cols

## dim(data_all) gives a 58,002 by 58 matrix, hence from 2 to 58, skipping every other column gives
## the response values excluding the gene names
## reserve all rows but tidy the columns
count_df = data_all[,c(seq(2,58,2))]
count_df

## append row names (ENSG*) from data_all to count_df
row.names(count_df) = data_all$V1...1
count_df

# `P` stands for Participants, in sequence of files read
dataSet_names = c("basal.P1", "AT.1h.P1", "AT.4h.P1", "RT.1h.P1", "RT.4h.P1",
                  "basal.P2", "AT.1h.P2", "AT.4h.P2", "RT.1h.P2", "RT.4h.P2",
                  "basal.P3", "AT.1h.P3", "AT.4h.P3", "RT.1h.P3", "RT.4h.P3",
                  "basal.P4", "AT.1h.P4",             "RT.1h.P4", "RT.4h.P4",
                  "basal.P5", "AT.1h.P5", "AT.4h.P5", "RT.1h.P5", "RT.4h.P5",
                  "basal.P7", "AT.1h.P7", "AT.4h.P7", "RT.1h.P7", "RT.4h.P7")

# setting column names
names(count_df) = dataSet_names
```

```{r}
head(count_df)
```

## Pre-processing and normalization
Create a dataframe `targets` to summarize the experimental design.
```{r}
## create an empty NA matrix of 29 by 2
targets <- as.data.frame(matrix(NA,length(names(count_df)),2))

## change the column names of targets
names(targets) <- c("sample","condition")

## change the row names of targets under 'sample' to 'basal.P1', ...
targets$sample <- names(count_df)

## remove the participants ('P1', 'P2', ...) in column names of count_df and append under 'condition'
## column of 'targets'
targets$condition <- gsub(".P[1-7]$","",targets$sample)

head(targets)
```

Plots to check the data after a log2 transformation (no normalisation).
Meaning of log2 transformation on normalizing gene expression:
1. Calculate fold changes rather than additive changes
2. Minimize heteroscedasticity (mean-variance relationship)
```{r}
## Retain rows with a positive sum
count_df <- count_df[rowSums(count_df) > 0,]

## Remaining 0 entries have to be made as NA so that log2 transformation is possible (cannot log on zero's)
count_df[count_df == 0] <- NA
```

```{R}
# make the plots using PCA analysis
plots <- magicPlotMakerLight(df = log2(count_df), targets = targets)
# plot(plots[[1]])
plot(plots[[1]] + geom_hline(yintercept=0.5)) #violin plot gemo_hline() to see where bimodal starts
plot(plots[[2]]) 

```
There is a bimodal distribution based on the violin plot, usually this is because a lot of genes are expressed under the RNAseq detection threshold and will give rise to a noisy sub-distribution. Hence we want to rid of those reads and the transcripts with less than 3 log2(counts) are excluded (Usually, a cleaned-up dataframe will have roughly between 9000 and 15000 measured genes).

**check if 3 log2(counts) is appropriate (4 log2(counts) only provided ~6000 genes)
  -> adjusted to '0.5 log2(counts)' -> as seen with hline above, bimodal distribution is at ~0.5.
```{r}
count_df[log2(count_df) < 0.5 ] <- NA
count_df <- count_df[rowSums(is.na(count_df[,c(1:3)])) < 2,] #c(1:3): basal.P1 AT.1h.P1 AT.4h.P1
count_df <- count_df[rowSums(is.na(count_df[,c(4:6)])) < 2,] #c(4:6): RT.1h.P1 RT.4h.P1 basal.P2
```

## VSN Normalization

```{r}
## now we can normalise the cleaned dataframe using vsn
fit <- vsn::vsnMatrix(as.matrix(count_df)) #train vsn parameters
meanSdPlot(fit)
```
The mean/sd trend is reasonably flat (i.e., red line) and there is minimal fragmenting. Good to continue

```{r}
## predict using the fit data from last step
count_df_vsn <- as.data.frame(vsn::predict(fit, as.matrix(count_df)))
```

```{r}
## whether subjects separate into distinct groups based on the continuous response - expression level
## PC1: explains most of the variability, best fit of data points
plots <- magicPlotMakerLight(df = log2(count_df_vsn), targets = targets)
plot(plots[[1]]) #violins
plot(plots[[2]]) #PCA
```
Are the conditions separated adequately by the second component? There is good separation between basal and AT_4h / RT_4h. There is some lack of separation between basal and AT_1h / RT_1h, such that there is unlikely to be much difference in gene expression (logical as gene expression likely requires a longer time frame to take full effect). 

## Identifier kung-fu (i.e., switching from Ensembl IDs to UniProt)
```{r}
## this identifier matching dataframe was retrieved from uniprot:
## trim_ws: trim the leading and trailing white spaces
## escape_double: replace """" double quotes with single \"

## read from uniprot mapping file and remove NA entries
gene_id_mapping_from_uniprot <- as.data.frame(
  read_delim("/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/support/gene_id_mapping_from_uniprot.tab", 
             "\t", escape_double = FALSE, trim_ws = TRUE))
gene_id_mapping_from_uniprot <- gene_id_mapping_from_uniprot[!is.na(gene_id_mapping_from_uniprot$`Gene names`),]

## let's make a pseudo dictionary to make the mapping efficient
## gsub: substitute regex .* with gene names from uniprot
## gsub pattern: space followed by 0 or more chars, replaced by "" in gene names
ensembl_to_symbol <- gsub(" .*","",gene_id_mapping_from_uniprot$`Gene names`)

## map the uniprot names with genes in our experiment
## now each ENSG* is mapped to its corresponding gene name
names(ensembl_to_symbol) <- gene_id_mapping_from_uniprot[,1]

## remove all genes that have no gene symbol from our count dataframe
row.names(count_df_vsn) <- gsub("[.][1-7]*","",row.names(count_df_vsn))

## eliminate the gene names not mapped to ensembl_to_symbol
count_df_vsn <- count_df_vsn[row.names(count_df_vsn) %in% names(ensembl_to_symbol),]

## now let's convert ids with the pseudo dictionary
## now all gene names are replaced with those from uniprot
for(i in 1:length(count_df_vsn[,1]))
{
  row.names(count_df_vsn)[i] <- ensembl_to_symbol[row.names(count_df_vsn)[i]]
}

```

## Write count and target files for further analysis
```{r}
to_write <- count_df_vsn
to_write$gene <- row.names(to_write)

## to write has one extra row with gene compared to count_df_vsn
to_write <- to_write[,c(length(to_write[1,]),1:(length(to_write[1,])-1))]
write_csv(to_write, 
          file = "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/count_df_vsn.csv")
write_csv(targets, "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/targets.csv")
```

### 2: Differential analysis
Differential analysis of the transcriptomic data
```{r}
library(limma)
```

### Limma differential analysis
Simple differential analysis using Limma
```{r}
unique(targets$condition)
```
```{r}
comparisons = list("B_vs_AT.1h"=c(2,-1), "B_vs_AT.4h"=c(3,-1), "AT.1h_vs_AT.4h"=c(3,-2), 
                   "B_vs_RT.1h"=c(4,-1), "B_vs_RT.4h"=c(5,-1), "RT.1h_vs_RT.4h"=c(5,-4))  
limmaRes = runLimma(measurements = count_df_vsn,
                    targets = targets,
                    comparisons = comparisons)

```
```{r}
#once limma has run, we extract the statistics data frame to summarize the differential analysis

#toptable: Extract a table of the top-ranked genes from a linear model fit.
#toptable parameters:
#fit: For topTable, fit should be an object of class MArrayLM as produced by lmFit and eBayes.
#coef: column number or column name specifying which coefficient or contrast of the linear model is of interest. here
#refers to contrast #1 (basal_vs_AT.1h or c(2,-1))
#number: maximum number of genes to list: 8470

#'This function is simply designed to format the toptable of limma with first column as gene identifiers instead of only row.names.'
#'@param ttop a toptable dataframe generated by the topTable function of limma
#Basal versus AT 1 hour (change later - 1 vs basal)
ttop_B_vs_AT.1h <- ttopFormatter(topTable(limmaRes[[1]], coef = 1, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
#rnorm: random generation for the normal distribution
#pnorm: distribution function for the normal distribution
null_model <- pnorm(rnorm(length(ttop_B_vs_AT.1h[,1])))
plot(sort(null_model), sort(ttop_B_vs_AT.1h$P.Value) ,
     xlim = c(1,0), ylim = c(1,0),
     title("AT 1 hour versus basal")) #not bad, not great, let's proceed
abline(coef = c(0,1))
```
This plot is used to see the deviance from the diagonal line. Deviance above the diagonal indicates an increase in expression (smaller p-values vs a random sample), deviance below the diagonal indicates a lower level of expression (larger p-value vs a random sample)

As suspected, there is a lack of expression between basal and AT.1hr

```{r}
#Basal versus AT 4 hour
ttop_B_vs_AT.4h <- ttopFormatter(topTable(limmaRes[[1]], coef = 2, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_B_vs_AT.4h[,1])))
plot(sort(null_model), sort(ttop_B_vs_AT.4h$P.Value), 
     xlim = c(1,0), ylim = c(1,0), 
     title("AT 4 hour versus basal"))
abline(coef = c(0,1))
```
As suspected, there is an increase in expression between basal and AT.4hr (deviance above diagonal)

```{r}
#AT 1 hour versus AT 4 hour
ttop_AT.1h_vs_AT.4h <- ttopFormatter(topTable(limmaRes[[1]], coef = 3, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_B_vs_AT.4h[,1])))
plot(sort(null_model), sort(ttop_B_vs_AT.4h$P.Value), 
     xlim = c(1,0), ylim = c(1,0),
     title("AT 4 hour versus AT 1 hour"))
abline(coef = c(0,1))
```
```{r}
#Basal versus RT 1 hour
ttop_B_vs_RT.1h <- ttopFormatter(topTable(limmaRes[[1]], coef = 4, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_B_vs_RT.1h[,1])))
plot(sort(null_model), sort(ttop_B_vs_RT.1h$P.Value), 
     xlim = c(1,0), ylim = c(1,0),
     title("RT 1 hour versus basal")) 
abline(coef = c(0,1))
```
Low level of expression

```{r}
#Basal versus RT 4 hour
ttop_B_vs_RT.4h <- ttopFormatter(topTable(limmaRes[[1]], coef = 5, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_B_vs_RT.4h[,1])))
plot(sort(null_model), sort(ttop_B_vs_RT.4h$P.Value), 
     xlim = c(1,0), ylim = c(1,0),
     title("RT 4 hour versus basal"))
abline(coef = c(0,1))
```
Quite high level of expression

```{r}
#RT 1 hour versus RT 4 hour
ttop_RT.1h_vs_RT.4h <- ttopFormatter(topTable(limmaRes[[1]], coef = 6, number = length(count_df_vsn[,1]), adjust.method = "fdr"))

#make a qqplot
null_model <- pnorm(rnorm(length(ttop_RT.1h_vs_RT.4h[,1])))
plot(sort(null_model), sort(ttop_RT.1h_vs_RT.4h$P.Value),
     xlim = c(1,0), ylim = c(1,0),
     title("RT 4 hour versus RT 1 hour")) 
abline(coef = c(0,1))
```

##Write the differential analysis output
```{r}
write_csv(ttop_B_vs_AT.1h, 
          file = "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/ttop_B_vs_AT.1h.csv") #no diff
write_csv(ttop_B_vs_AT.4h, 
          file = "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/ttop_B_vs_AT.4h.csv")
write_csv(ttop_AT.1h_vs_AT.4h, 
          file = "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/ttop_AT.1h_vs_AT.4h.csv")
write_csv(ttop_B_vs_RT.1h, 
          file = "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/ttop_B_vs_RT.1h.csv") #no diff
write_csv(ttop_B_vs_RT.4h, 
          file = "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/ttop_B_vs_RT.4h.csv") #high
write_csv(ttop_RT.1h_vs_RT.4h, 
          file = "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/standard_ttop_RT.1h_vs_RT.4h.csv")
```

### 3: Pathway activity (PROGENy)
Here I estimate the pathway activity from the Dickinson transcriptomic data using PROGENy

```{r}
#loading additional libraries
library(progeny)
library(dorothea)
library(tibble)
library(tidyr)
```

```{r}
Normalised_counts = count_df_vsn
Experimental_design = targets
```

Adjusting the format of the input files to make it suitable for running PROGENy

```{r}
Normalised_counts_matrix <- Normalised_counts %>% 
    dplyr::mutate_if(~ any(is.na(.x)),~ if_else(is.na(.x),0,.x)) %>% 
    as.matrix()

#Comparison of each condition
ttop_B.vs.AT.1h_matrix <- ttop_B_vs_AT.1h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_B_vs_AT.4h_matrix <- ttop_B_vs_AT.4h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_AT.1h_vs_AT.4h_matrix <- ttop_AT.1h_vs_AT.4h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_B_vs_RT.1h_matrix <- ttop_B_vs_RT.1h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_B_vs_RT.4h_matrix <- ttop_B_vs_RT.4h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

ttop_RT.1h_vs_RT.4h_matrix <- ttop_RT.1h_vs_RT.4h %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    dplyr::select(-"ID") %>%
    as.matrix()

```

## Pathway activity with Progeny (pathway activity estimator)
PROGENy estimates the activity of signaling pathways by combining corresponding gene sets with a linear model.
Other bulk tools: classic GO analysis combining GO gene sets with GSEA.
DoRothEA is a collection of resources of TF’s targets (regulons) that can serve as gene sets for TF activity inference.

First compute Progeny scores for every sample (with the replicates) using the normalised counts. It is worth noting that we are going to use the 200 most responsive genes per pathway (suggest 200-500)
-> changed to top 100 as per Aurelien

```{r}
PathwayActivity_counts <- progeny(Normalised_counts_matrix, scale=TRUE, organism="Human", top = 100)
Activity_counts <- as.vector(PathwayActivity_counts)
```

results in a heatmap
```{r}
paletteLength <- 100
myColor <- colorRampPalette(c("darkblue", "whitesmoke","indianred"))(paletteLength)
progenyBreaks <- c(seq(min(Activity_counts), 0, 
    length.out=ceiling(paletteLength/2) + 1),
    seq(max(Activity_counts)/paletteLength, 
    max(Activity_counts), 
    length.out=floor(paletteLength/2)))
progeny_hmap <- pheatmap(t(PathwayActivity_counts),fontsize=14, 
    fontsize_row = 10, fontsize_col = 10, 
    color=myColor, breaks = progenyBreaks, 
    main = "PROGENy (100)", angle_col = 45,
    treeheight_col = 0,  border_color = NA)

#Pathways:
#NFkB Pathway: Moderate exercise training decreases NF-kB activation and represses inflammatory gene expression, most active in basal or AT/RT.1h conditions.
#TNF-a Pathway: Regulates inflammation and tissue injury. TNF-α was elevated immediately following acute heavy resistance exercise, and decreased at 24 h and 48 h into recovery in those receiving no treatments. 
#PI3K-Akt Pathway is an intracellular signal transduction pathway that promotes metabolism, proliferation, cell survival, growth and angiogenesis in response to extracellular signals.

```
Enrichment analysis using a competitive permutation approach to assess the significance of the pathway activity. 
Output a Normalized Enrichment Score (NES) for each pathway.
PROGENy pathway signatures were applied to differential expression t-values from limma. Based on an empirical null distribution generated through 10,000 times gene-wise permutation and the percentile corresponding to the observed value, the significance score was derived.
z score: distance from mean of the distribution measured in standard deviations
## AT 1 hour vs basal
## To do: AT 4 hour vs basal
```{r}
PathwayActivity_zscore <- progeny(ttop_B.vs.AT.1h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>% #add column name to all rows
    dplyr::arrange(NES) %>% #sort pathway by ascending NES
    dplyr::mutate(Pathway = factor(Pathway))

#reorder the levels of Pathway variables based on the magnitude of its second arg NES
ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("AT 1 hour versus basal") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```
The MAPK pathway is the most active pathway at the 1 hour mark following AT. We can therefore visualize the MAPK most responsive genes (progeny weights) along with their t_values to interpret the results. In the scatterplot, we can see the genes that are contributing the most to the pathway enrichment. 

```{r ProgenyScatter_1_AT1.vs.B, message=FALSE, warning=FALSE}
# getting a model matrix with 100 top significant genes for each pathway and converting to df
# https://saezlab.github.io/progeny/reference/index.html
prog_matrix <- getModel("Human", top=100) %>% 
    as.data.frame()  %>%
    tibble::rownames_to_column("GeneID")

ttop_B_vs_AT.1h_df <- ttop_B.vs.AT.1h_matrix %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column("GeneID")

scat_plots <- progeny::progenyScatter(df = ttop_B_vs_AT.1h_df, #y, gene level stat t values
    weight_matrix = prog_matrix, #x
    statName = "t_values", verbose = FALSE)
```

```{r ProgenySccater_2_AT1.vs.B, dpi=300}
plot(scat_plots[[1]]$`MAPK`) # red/blue = positive/negative contributions of genes to the progeny pathway score

```
Progeny results as an optional input for **CARNIVAL**. I therefore run **PROGENy** again with slightly different parameters, setting `z_scores = FALSE` so that **PROGENy** returns pathway activity values (normalized z score) between 1 and -1, rather than converting to Z-Scores.

```{r ProgenyCARNIVAL_AT1.vs.B}
PathwayActivity_CARNIVALinput_B_vs_AT.1h <- progeny(ttop_B.vs.AT.1h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = FALSE) %>%
    t () %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "Pathway") 
colnames(PathwayActivity_CARNIVALinput_B_vs_AT.1h)[2] <- "score"
write_csv(PathwayActivity_CARNIVALinput_B_vs_AT.1h, 
    "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/Results/progeny/PathwayActivity_CARNIVALinput_B_vs_AT.1h.csv")
```

## AT 4 hour vs basal
```{r}
PathwayActivity_zscore <- progeny(ttop_B_vs_AT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("AT 4 hour versus basal") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```
```{r ProgenyScatter_1_AT4.vs.B, message=FALSE, warning=FALSE}
prog_matrix <- getModel("Human", top=100) %>% 
    as.data.frame()  %>%
    tibble::rownames_to_column("GeneID")

ttop_B_vs_AT.4h_df <- ttop_B_vs_AT.4h_matrix %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column("GeneID")

scat_plots <- progeny::progenyScatter(df = ttop_B_vs_AT.4h_df, 
    weight_matrix = prog_matrix, 
    statName = "t_values", verbose = FALSE)
```

```{r ProgenyScatter_2_AT4.vs.B, dpi=300}
plot(scat_plots[[1]]$`NFkB`) 
```
```{r ProgenyCARNIVAL_AT4.vs.B}
PathwayActivity_CARNIVALinput_B_vs_AT.4h <- progeny(ttop_B_vs_AT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = FALSE) %>%
    t () %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "Pathway") 
colnames(PathwayActivity_CARNIVALinput_B_vs_AT.4h)[2] <- "score"
write_csv(PathwayActivity_CARNIVALinput_B_vs_AT.4h, 
    "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/Results/progeny/PathwayActivity_CARNIVALinput_B_vs_AT.4h.csv")
```

## AT 1 hour versus AT 4 hour
```{r}
PathwayActivity_zscore <- progeny(ttop_AT.1h_vs_AT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("AT 1 hour versus AT 4 hour") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```

## RT 1 hour versus basal
```{r}
PathwayActivity_zscore <- progeny(ttop_B_vs_RT.1h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("Basal versus RT 1 hour") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```


## RT 4 hour versus basal
```{r}
PathwayActivity_zscore <- progeny(ttop_B_vs_RT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("RT 4 hour versus basal") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```
```{r ProgenyScatter_1_RT4.vs.B, message=FALSE, warning=FALSE}
prog_matrix <- getModel("Human", top=100) %>% 
    as.data.frame()  %>%
    tibble::rownames_to_column("GeneID")

ttop_B_vs_RT.4h_df <- ttop_B_vs_RT.4h_matrix %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column("GeneID")

scat_plots <- progeny::progenyScatter(df = ttop_B_vs_RT.4h_df, 
    weight_matrix = prog_matrix, 
    statName = "t_values", verbose = FALSE)
```

```{r ProgenyScatter_2_RT4.vs.B, dpi=300}
plot(scat_plots[[1]]$`NFkB`) 
plot(scat_plots[[1]]$`TNFa`)
plot(scat_plots[[1]]$`MAPK`) 
plot(scat_plots[[1]]$`EGFR`) 
plot(scat_plots[[1]]$`JAK-STAT`) 


```

```{r ProgenyCARNIVAL_RT4.vs.B}
PathwayActivity_CARNIVALinput_B_vs_RT.4h <- progeny(ttop_B_vs_RT.4h_matrix, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = FALSE) %>%
    t () %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "Pathway") 
colnames(PathwayActivity_CARNIVALinput_B_vs_RT.4h)[2] <- "score"
write_csv(PathwayActivity_CARNIVALinput_B_vs_RT.4h, 
    "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/Results/progeny/PathwayActivity_CARNIVALinput_B_vs_RT.4h.csv")
```

## RT 1 hour versus RT 4 hour
```{r}
PathwayActivity_zscore <- progeny(ttop_RT.1h_vs_RT.4h_matrix, 
    scale=TRUE, organism="Human", top = 200, perm = 10000, z_scores = TRUE) %>%
    t()
colnames(PathwayActivity_zscore) <- "NES"

```

```{r}
PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) %>% 
    rownames_to_column(var = "Pathway") %>%
    dplyr::arrange(NES) %>%
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES), y = NES)) + 
    ggtitle("RT 1 hour versus RT 4 hour") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")
```

### 4: Transcription Factor activity (DoRothEA)
Here I estimate transcription factor activity from transcriptomics data using **DoRothEA**.
DoRothEA is a comprehensive resource containing a curated collection of TFs and their transcriptional targets. 
The set of genes regulated by a specific TF is known as regulon. 
Each TF-target interaction is defined by a confidence level based on the volume of supporting evidence. 
The confidence levels range from A (highest confidence) to E (lowest confidence)
```{r}
library(ggrepel)
```

Dorothea input files
```{r Dorothea inputs}
# Normalised_counts_dorothea = count_df_vsn
# Experimental_design_dorothea = targets
Normalised_counts_dorothea <- read_csv("/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/count_df_vsn.csv")
Experimental_design_dorothea <- read_csv("/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/targets.csv")
ttop_B_vs_AT.4h_dorothea <- read_csv("/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/ttop_B_vs_AT.4h.csv")
ttop_B_vs_RT.4h_dorothea <- read_csv("/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/data/ttop_B_vs_RT.4h.csv")
```

Modify file formats
```{r Dorothea file modification, message=FALSE}
#replace NA entries with 0
Normalised_counts_matrix_dorothea <- Normalised_counts_dorothea %>% 
    dplyr::mutate_if(~ any(is.na(.x)),~ if_else(is.na(.x),0,.x)) %>% 
    tibble::column_to_rownames(var = "gene") %>% 
    as.matrix()

ttop_B_vs_AT.4h_dorothea_matrix <- ttop_B_vs_AT.4h_dorothea %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    column_to_rownames(var = "ID") %>%
    as.matrix()

ttop_B_vs_RT.4h_dorothea_matrix <- ttop_B_vs_RT.4h_dorothea %>% 
    dplyr::select(ID, t) %>% 
    dplyr::filter(!is.na(t)) %>% 
    column_to_rownames(var = "ID") %>%
    as.matrix()
```

## Transcription Factor activity with DoRothEA

We estimate the transcription factor (TF) activity using the **DoRothEA** R package. 
We select interactions with confidence level A, B and C. 

```{r loadDorothea, message=FALSE}
## We load Dorothea Regulons
data(dorothea_hs, package = "dorothea")
regulons <- dorothea_hs %>%
  dplyr::filter(confidence %in% c("A", "B","C"))
```

Note that for **DoRothEA**, we proceed the other way around than for **PROGENy**. 
In **PROGENy**, we calculate the pathway_activity_counts directly which is feed into pheatmap().
We have many TFs, so we cannot clearly visualize all of them in the same heatmap. 
That is why we first compute a TF activity enrichment analysis using the statistics 
from the differential expression analysis. 
This will allow us to select the TFs whose activity varies with the conditions under study. 

**DoRothEA** is usually used together with VIPER where TF activities are computed based on the mRNA 
expression levels of its targets. 
We therefore can consider TF activity as a proxy of a given transcriptional state.

It is important to set the parameter `eset.filter` to `FALSE`. In this case,
we set the minimum size of regulons to five (`minsize`). I strongly recommend
to check `?viper` to set the parameters that best fit your needs. 

@param eset ExpressionSet object or Numeric matrix containing the expression data or gene expression signatures, with samples in columns and genes in rows. Used by Protein-activity by Enriched Regulon analysis(?)
@param minsize Integer indicating the minimum number of targets allowed per regulon
@param nes Logical, whether the enrichment score reported should be normalized
Function is a wrapper for viper class using DoRothEA regulons.

--How to determine *minsize*? Viper documentation does not include a description

```{r ViperStat, message=FALSE}
tf_activities_stat_B_vs_AT.4h <- dorothea::run_viper(ttop_B_vs_AT.4h_dorothea_matrix, regulons,
    options =  list(minsize = 5, eset.filter = FALSE, 
    cores = 1, verbose = FALSE, nes = TRUE))

tf_activities_stat_B_vs_RT.4h <- dorothea::run_viper(ttop_B_vs_RT.4h_dorothea_matrix, regulons,
    options =  list(minsize = 5, eset.filter = FALSE, 
    cores = 1, verbose = FALSE, nes = TRUE))
```

## AT 4 hour versus basal
We now display the top 25 normalized enrichment scores (NES) for the TFs in a 
bar plot.

```{r ViperBarplot AT 4h vs basal, message=FALSE, dpi=300}
tf_activities_stat_top25_B_vs_AT.4h <- tf_activities_stat_B_vs_AT.4h %>%
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::rename(NES = "t") %>%
    dplyr::top_n(25, wt = abs(NES)) %>% #top 25, ordered by absolute values of NES, select both - && +ve
    dplyr::arrange(NES) %>% 
    dplyr::mutate(GeneID = factor(GeneID))

ggplot(tf_activities_stat_top25_B_vs_AT.4h, aes(x = reorder(GeneID, NES), y = NES)) + 
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Transcription Factors")
```

To interpret the results, we can use a volcano plot to look at the expression of targets of one of the 
most de(/up)regulated TFs, such as TCF4 

*Volcano plot*: blue = down regulated genes, red = upregulated genes, logFC = log(fold change). Within the volcano plot, the most up/down regulated genes are towards the right/left, respectively. And the most statistically significant genes are towards the top

```{r Volcano RT 4h vs basal, warning=FALSE, dpi=300}
targets_NFKB1 <- regulons$target[regulons$tf == "NFKB1"] #targets of "TCF4"

#'This function is designed to generate a stylish and practical volcano plot to visual the result of a differential analysis, with simple required inputs.
#'The plot features two bi-symptotic curves to give a visual support for p-value and fold change threshold.'
# Parameters of volcano_nice():
#'@param FCIndex the column number corresponding to the foldchanges
#'@param pValIndex the column number corresponding to the p-values
#'@param IDIndex the column number corresponding to the identifiers
#'@param straight a boolean argument to indicate if the plot should feature bi-symptotic curves 
#'or straight lines to visualise the thresholds. In this case, we use bi-symptotic curves. 
#'@param nlabels number of labels to display

volcano_nice(as.data.frame(ttop_B_vs_AT.4h_dorothea[ttop_B_vs_AT.4h_dorothea$ID %in% targets_NFKB1,]), 
    FCIndex = 2, pValIndex = 5, IDIndex = 1,nlabels = 20, label = TRUE, 
    straight = FALSE) 
```
The TF activity enrichment results provided by **Viper** are used as an input in the **CARNIVAL** method. 
**CARNIVAL** tries to infer the most likely upstream signaling events leading to the current TF activity results. 

```{r WriteCsv AT 4h vs basal}
tf_activities_CARNIVALinput_AT.4h_vs_b<- tf_activities_stat_B_vs_AT.4h %>%
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "TF") 
write_csv(tf_activities_CARNIVALinput_AT.4h_vs_b, "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/Results/dorothea/TFActivity_CARNIVALinput_AT4h_vs_B.csv")
```

## RT 4 hour versus basal
```{r ViperBarplot RT 4h vs basal, message=FALSE, dpi=300}
tf_activities_stat_top25_B_vs_RT.4h <- tf_activities_stat_B_vs_RT.4h %>%
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::rename(NES = "t") %>%
    dplyr::top_n(25, wt = abs(NES)) %>%
    dplyr::arrange(NES) %>% 
    dplyr::mutate(GeneID = factor(GeneID))

ggplot(tf_activities_stat_top25_B_vs_RT.4h, aes(x = reorder(GeneID, NES), y = NES)) + 
    ggtitle("RT 4 hour versus basal: TF activity") +
    geom_bar(aes(fill = NES), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Transcription Factors")
```
To interpret the results, we can look at the expression of targets of one of the 
most deregulated TFs, such as ARNTL 

```{r Volcano RT 4h vs basal, warning=FALSE, dpi=300}
targets_STAT3 <- regulons$target[regulons$tf == "STAT3"]
volcano_nice(as.data.frame(ttop_B_vs_RT.4h_dorothea[ttop_B_vs_RT.4h_dorothea$ID %in% targets_STAT3,]), 
    FCIndex = 2, pValIndex = 5, IDIndex = 1,nlabels = 20, label = TRUE, 
    straight = FALSE) 

```
The TF activity enrichment results provided by **Viper** are used as an input
in the **CARNIVAL** method. **CARNIVAL** tries to infer the most likely 
upstream signaling events leading to the current TF activity results. 

```{r WriteCsv RT 4h vs basal}
tf_activities_CARNIVALinput_RT.4h_vs_b<- tf_activities_stat_B_vs_RT.4h %>%
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "TF") 
write_csv(tf_activities_CARNIVALinput_RT.4h_vs_b, "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/Results/dorothea/TFActivity_CARNIVALinput_RT4h_vs_B.csv")
```

We now compute TF activities per sample (with the replicates) using the 
normalised counts. We display the results of the previous 25 TFs in a Heatmap.

```{r ViperCounts AT 4h vs basal, message=FALSE}
#The normalizing of a dataset using the mean value and standard deviation is known as scaling.
#Used mainly for data not measured in the same way.
tf_activities_counts <- 
    dorothea::run_viper(Normalised_counts_matrix_dorothea, regulons,
    options =  list(minsize = 5, eset.filter = FALSE, 
    cores = 1, verbose = FALSE, method = c("scale")))

#filter based on top 25 deregulated TFs from last step
tf_activities_counts_filter <- tf_activities_counts %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::filter(GeneID %in% tf_activities_stat_top25_B_vs_AT.4h$GeneID) %>%
    column_to_rownames(var = "GeneID") %>%
    as.matrix()

tf_activities_vector <- as.vector(tf_activities_counts_filter)
```

```{r ViperHeatMap AT 4h vs basal}
paletteLength <- 100
myColor <- 
    colorRampPalette(c("darkblue", "whitesmoke","indianred"))(paletteLength)

dorotheaBreaks <- c(seq(min(tf_activities_vector), 0, 
    length.out=ceiling(paletteLength/2) + 1),
    seq(max(tf_activities_vector)/paletteLength, 
    max(tf_activities_vector), 
    length.out=floor(paletteLength/2)))

dorothea_hmap <- pheatmap(tf_activities_counts_filter,
    fontsize=14, fontsize_row = 8, fontsize_col = 8, 
    color=myColor, breaks = dorotheaBreaks,
    main = "Dorothea ABC: AT 4h vs basal", angle_col = 45,
    border_color = NA)

```

```{r ViperCounts RT 4h vs basal, message=FALSE}
tf_activities_counts_filter <- tf_activities_counts %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "GeneID") %>%
    dplyr::filter(GeneID %in% tf_activities_stat_top25_B_vs_RT.4h$GeneID) %>%
    column_to_rownames(var = "GeneID") %>%
    as.matrix()

tf_activities_vector <- as.vector(tf_activities_counts_filter)
```

```{r ViperHeatMap RT 4h vs basal}
paletteLength <- 100
myColor <- 
    colorRampPalette(c("darkblue", "whitesmoke","indianred"))(paletteLength)

dorotheaBreaks <- c(seq(min(tf_activities_vector), 0, 
    length.out=ceiling(paletteLength/2) + 1),
    seq(max(tf_activities_vector)/paletteLength, 
    max(tf_activities_vector), 
    length.out=floor(paletteLength/2)))
dorothea_hmap <- pheatmap(tf_activities_counts_filter,
    fontsize=14, fontsize_row = 8, fontsize_col = 8, 
    color=myColor, breaks = dorotheaBreaks,
    main = "Dorothea ABC: RT 4h vs basal", angle_col = 45,
    treeheight_col = 0,  border_color = NA)

```


## ----

### 5: Network reconstrcution with CARNIVAL
AT 4h versus B: To do
RT 4h vs B: 

```{r, message=FALSE}
#loading additional libraries
# library(CARNIVAL)
#devtools::install_github("saezlab/CARNIVAL@v1.3")
library(OmnipathR)

## We also load the support functions
source("/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/support/assignPROGENyScores.r")
source("/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/support/generateTFList.r")
#source("carnival_visNetwork.r")
```

Inputting files for carnival: AT.4h vs basal
```{r loadInput, message=FALSE}
## We read the normalised counts and the experimental design 
# tf_activities <- tf_activities_CARNIVALinput_RT.4h_vs_b
# PathwayActivity <- PathwayActivity_CARNIVALinput_B_vs_RT.4h
tf_activities <- tf_activities_CARNIVALinput_RT.4h_vs_b
PathwayActivity <- PathwayActivity_CARNIVALinput_B_vs_RT.4h

```


## Getting the scaffold network from Omnipath
Before running **CARNIVAL**, we need to create or upload a scaffold network.
This will be _"the map"_ that the ILP algorithm will follow to find the causal network.
We use **Omnipath** to obtain the signed and directed interactions from all the available resources.
CARNIVAL requires this information in a _sif_ table (node1, interaction, node2) format,
therefore we use the _consensus_ columns of direction (consensus_direction) and
sign (consensus_stimulation and consensus_inhibition) to extract it.

The query returns 0/1 as logic status of being a stimulation or an inhibition reaction. 
Thus, this output is reformulated as 1/-1 to indicate stimulation or inhibition, respectively.
We can keep either the interactions that are consistent, or both alternatives (e.g. A 1 B; A -1 B).
In this example, we keep the consistent ones.

```{r omnipathSIF, message=FALSE}

omniR <- import_omnipath_interactions()
  
# signed and directed
omnipath_sd <- omniR %>% dplyr::filter(consensus_direction == 1 & #directed with either inhibition or stimulation
                                (consensus_stimulation == 1 | 
                                 consensus_inhibition == 1
                                 ))
  
# changing 0/1 criteria in consensus_stimulation/inhibition to -1/1 (converting *both* columns to 1 or -1 - either column indicated stimulation or inhibition)
# now all inhibition denoted by -1
# stimulation denoted by 1 regardless of column types
omnipath_sd$consensus_stimulation[which(omnipath_sd$consensus_stimulation == 0)] = -1
omnipath_sd$consensus_inhibition[which(omnipath_sd$consensus_inhibition == 1)] = -1
omnipath_sd$consensus_inhibition[which(omnipath_sd$consensus_inhibition == 0)] = 1

# check consistency on consensus sign and select only those in a SIF format
sif <- omnipath_sd[,c('source_genesymbol', 'consensus_stimulation', 'consensus_inhibition', 'target_genesymbol')] %>%
      dplyr::filter(consensus_stimulation==consensus_inhibition) %>%
      unique.data.frame()

sif$consensus_stimulation <- NULL
colnames(sif) <- c('source', 'interaction', 'target')
# remove complexes
sif$source <- gsub(":", "_", sif$source)
sif$target <- gsub(":", "_", sif$target)

#save SIF
write_tsv(sif, "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/Results/omnipath/omnipath_carnival.tsv")

```

## Transcription Factor and pathway activities for CARNIVAL

We use the supplementary functions _generateTFList.r_ and _assignPROGENyScores.r_
to shift the formats of tf_activities and PathwayActivity to the one required by CARNIVAL.

For AT.4h vs basal:
```{r shiftFormats, message=FALSE}

# dorothea for CARNIVAL
tf_activities_carnival <- data.frame(tf_activities, stringsAsFactors = F)
rownames(tf_activities_carnival) <- tf_activities$TF
tf_activities_carnival$TF <- NULL

# generate a list with each TF and its corresponding t value
tfList = generateTFList(tf_activities_carnival, top=100, access_idx = 1)

# progeny for CARNIVAL
#This function is used to account for the PROGENy scores in the objective fu nction. 
#It creates a list object with progeny scores for a selected set of samples (by default for all of them)
load(file = system.file("progenyMembers.RData",package="CARNIVAL"))

PathwayActivity_carnival <- data.frame(PathwayActivity, stringsAsFactors = F)
rownames(PathwayActivity_carnival) <- PathwayActivity_carnival$Pathway
PathwayActivity_carnival$Pathway <- NULL
progenylist = assignPROGENyScores(progeny = t(PathwayActivity_carnival), 
                                            progenyMembers = progenyMembers, 
                                            id = "gene", 
                                            access_idx = 1)
saveRDS(progenylist, "/Users/Administrator/Desktop/PathwayAnalysis_RPS6KB1/CARNIVAL/Results/progeny/myProgenyList.rds")
```

## Running CARNIVAL

CARNIVAL has been developed to find the causal link between the activities of the transcription factors (TFs) and the 'perturbed' nodes.
In current version, v1.0.0, we have 3 main inputs that we have to provide:

+ _measObj_: The TFs' activities (like the ones we have obtained from DoRothEA)
+ _inputObj_: The 'perturbed' nodes we want that CARNIVAL connects with the activity of TFs. 
There are 3 ways of using it:
(1) Give the name and sign of the selected nodes; 
(2) Give the name only, so the algorithm will select the sign that best fit the models,
(3) Give _NULL_ as value will create a "Perturbation" node that will try both signs for all 'initial' nodes of the given network ( _netObj_ ).
+ _netObj_: The network that will serve as map to connect the TFs' activities ( _measObj_ ) and the perturbed nodes ( _inputObj_ )

Although it is not required, a fourth object called _weightObj_ can be also given. 
This object gives values ranged from -1 to 1 for a set of nodes of the network.
The aim of _weightObj_ is helping the solver to find optimal solutions faster.

In the present example, we use assign as perturbation nodes all the "initial" nodes (option 2),
and as _weightObj_ the PROGENy scores assigned to the most representative genes of the calculated pathways,

Please, check the [CARNIVAL](https://saezlab.github.io/CARNIVAL/) page to get some more insight.
For more specific technical details, as how to install different ILP solvers that CARNIVAL supports,
please check [CARNIVAL vignette](https://bioconductor.org/packages/release/bioc/vignettes/CARNIVAL/inst/doc/CARNIVAL.html).
C:/Program Files/IBM/ILOG/CPLEX_Studio2211/cplex/bin/x64win64/cplex.exe
```{r}
# Standard CARNIVAL
targets = c('RPS6KB1')
iniciators_std = base::data.frame(base::matrix(data = c(1), nrow = 1, ncol=length(targets)), stringsAsFactors = F)
colnames(iniciators_std) = targets

#filter PKN to remove genes that are not expressed
upstream_inputs <- iniciators_std
downstream_inputs <- data.frame(tfList$t)
meta_network <- sif
expressed_genes <- rownames(ttop_B_vs_RT.4h_matrix) #ttop_RT.1h_vs_RT.4h$ID
        
meta_network_filtered <- cosmosR:::filter_pkn_expressed_genes(expressed_genes, meta_pkn = meta_network)

#filter the inputs that are not in PKN
upstream_inputs_filtered <- cosmosR:::filter_input_nodes_not_in_pkn(upstream_inputs, meta_network_filtered)
downstream_inputs_filtered <- cosmosR:::filter_input_nodes_not_in_pkn(downstream_inputs, meta_network_filtered)

#Filter inputs and prune the meta_network to only keep nodes that can be found downstream of the inputs
#The number of step is quite flexible, 7 steps already covers most of the network

n_steps <- 7

# in this step we prune the network to keep only the relevant part between upstream and downstream nodes
meta_network_filtered <- cosmosR:::keep_controllable_neighbours(meta_network_filtered
                                                       , n_steps,
                                                       names(upstream_inputs_filtered))
downstream_inputs_filtered <- cosmosR:::filter_input_nodes_not_in_pkn(downstream_inputs_filtered, meta_network_filtered)
meta_network_filtered <- cosmosR:::keep_observable_neighbours(meta_network_filtered
                                                              , n_steps, 
                                                              names(downstream_inputs_filtered))
upstream_inputs_filtered <- cosmosR:::filter_input_nodes_not_in_pkn(upstream_inputs_filtered, meta_network_filtered)
```

```{r carnival, message=FALSE}
library(CARNIVAL)
getwd()
carnival_result = runCARNIVAL( inputObj= upstream_inputs_filtered, 
                               measObj = downstream_inputs_filtered,
                               netObj =  meta_network_filtered, 
                               weightObj = progenylist$score,
                               solverPath = "/Users/Alex/Desktop/CPLEX_Studio2211/cplex/bin/x86-64_osx/cplex",
                               solver = "cplex",
                               timelimit=50000,
                               betaWeight = 0)

```

```{r}
print(carnival_result)
```


```{r}
timeStamp = Sys.time()
filename = paste0(format(timeStamp, "%Y%m%d_%H%M%S_"), "carnival.rds")
carnival_result$weightedSIF <- data.frame(carnival_result$weightedSIF, stringsAsFactors = F)
carnival_result$weightedSIF$Sign <- as.numeric(carnival_result$weightedSIF$Sign)
carnival_result$weightedSIF$Weight <- as.numeric(carnival_result$weightedSIF$Weight)
carnival_result$weightedSIF = carnival_result$weightedSIF[carnival_result$weightedSIF$Weight !=0,]

carnival_result$nodesAttributes <- data.frame(carnival_result$nodesAttributes, stringsAsFactors = F)
carnival_result$nodesAttributes$ZeroAct <- as.numeric(carnival_result$nodesAttributes$ZeroAct)
carnival_result$nodesAttributes$UpAct <- as.numeric(carnival_result$nodesAttributes$UpAct)
carnival_result$nodesAttributes$DownAct <- as.numeric(carnival_result$nodesAttributes$DownAct)
carnival_result$nodesAttributes$AvgAct <- as.numeric(carnival_result$nodesAttributes$AvgAct)

saveRDS(carnival_result, file = filename)

filename_weightedSIF = paste0(format(timeStamp, "%Y%m%d_%H%M%S_"), "carnival_weightedSIF.csv")
filename_nodesAttributes = paste0(format(timeStamp, "%Y%m%d_%H%M%S_"), "carnival_nodeAttributes.csv")


write.csv(carnival_result$weightedSIF, filename_weightedSIF)
write.csv(carnival_result$nodesAttributes, filename_nodesAttributes)
```

## Session Info Details

```{r sessionInfo, echo=FALSE, eval=TRUE}
sessionInfo()
```
